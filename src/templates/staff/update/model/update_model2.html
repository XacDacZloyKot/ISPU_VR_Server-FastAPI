{% extends '/location/base.html' %}

{% block css %}
    <link rel="stylesheet" href="{{ url_for('static', path='css/base/form.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/base/select.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/base/multiple_select.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/location/create_location.css') }}">
{% endblock %}

{% block navTitle %}
    <p class="navbar__title">Обновление модели #{{ model.id }}</p>
{% endblock %}

{% block content %}
    <form action="{{ url_for('post_create_location_page') }}" method="post" class="form-container">
        <div class="form-group">
            <label for="status-id">Датчик:</label>
            <div class="select-wrapper">
                <select name="status" id="status-id" required>
                    {% for option in sensor_types %}
                        <option value="{{ option.id }}" {% if option.id == model.sensor_type.id %}selected{% endif %}>
                            {{ option.name }}
                        </option>
                    {% endfor %}
                </select>
                <div class="select-arrow-1"></div>
            </div>
        </div>
        <div class="form-group">
            <label for="fields-id">Параметры:</label>
            <div class="select select--multiple">
                <select name="fields_selected" id="fields-id" class="multi-select" multiple size="10">
                    <!-- Параметры будут обновлены динамически -->
                </select>
            </div>
        </div>
        <div class="submit-container">
            <button type="submit" class="button orange submit">Создать</button>
        </div>
    </form>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const statusSelect = document.getElementById('status-id');
        const fieldsSelect = document.getElementById('fields-id');

        // Получение данных из Django шаблона
        const sensorValues = {{ sensor_values | tojson | safe }};
        const selectedFields = new Set({{ selected_fields | tojson | safe }});

        // Функция для заполнения полей на основе выбранного типа датчика
        function populateFields(sensorType) {
            // Очистка текущих опций
            fieldsSelect.innerHTML = '';

            // Фильтрация значений датчиков по выбранному типу
            const filteredFields = sensorValues.filter(field => field.sensor_type === sensorType);

            // Добавление новых опций
            filteredFields.forEach(field => {
                const option = document.createElement('option');
                option.value = field.id;
                option.textContent = `${field.field} ${field.value} ${field.measurement}`;
                if (selectedFields.has(field.id)) {
                    option.selected = true;
                }
                fieldsSelect.appendChild(option);
            });
        }

        // Обработчик изменения типа датчика
        statusSelect.addEventListener('change', function() {
            populateFields(this.options[this.selectedIndex].text); // Передаем название типа датчика
        });

        // Загрузка начальных полей на основе предвыбранного типа датчика
        populateFields(statusSelect.options[statusSelect.selectedIndex].text);
    });
    </script>
{% endblock %}
